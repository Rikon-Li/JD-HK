1. 基本类型和基本包装类型，基本包装的步骤
   基本类型：Undefined，Null，Boolean，Number，String，Symbol
   基本包装类型：Boolean，Number，String
   步骤：
   找到对应的包装对象类型，然后通过包装对象创建出一个和基本类型值相同的对象；
   然后这个对象就可以调用包装对象下的方法；
   之后这个临时创建的对象被销毁。
2. 原生对象和宿主对象，什么是宿主？
   原生对象（本地对象）：native object（ECMA所定义的对象：Number、String、Boolean、Object、Array、Function、Date、RegExp、内置对象(如 Math不需要实例化)、Error .....）
   宿主对象：host object（ 如 window、BOM、DOM ）
   宿主：
   web的运行环境，即操作系统、浏览器
3. 什么是事件流？
   事件流：事件的流向，事件的执行顺序，事件流分为事件冒泡和事件捕获：
   事件冒泡：事件从里向外发生，事件从最精确对象(target)开始触发，然后到最不精确的对象(document)触发；
   事件捕获：事件从外向里发生，事件从最不精确的对象(document)开始触发，然后到最精确对象(target)触发。
   W3C将两者进行中和，在任何W3C的事件模型中，事件先进入捕获阶段，再进入冒泡阶段。
4. 什么是事件模型？
   JavaScript中的两种事件模型：DOM0，DOM2。
   DOM0级事件模型：每个DOM对象只能注册一个相同类型的事件，注册多个则会发生覆盖，只执行最后一个事件函数。
   DOM2级事件模型：每个DOM对象可以注册多个相同类型的事件，不会发生覆盖，会依次的执行各个事件函数。
5. 三种继承方式
   构造函数继承：调用父类构造函数，并改变其中的this（bind，call，this）。
   原型链继承：将原型对象链接到另一个对象实现继承。
   混合继承：两种方法结合可以实现比较完美的继承。
6. for/of，for/in
   for in是ES5标准，遍历key. 
   for of是ES6标准，遍历value.
7. let，const，var
   let不允许重复声明变量；
   let声明变量仅在块级作用域内有效；
   不能通过let声明和形参相同的变量；
   let声明变量不会提升；
   const关键字，用来声明一个只读的常量。
   const常量一旦声明，常量将不能重新赋值
   const一旦声明，就必须立即初始化。
8. 暂时性死区TDZ
   ES6规定在某个区块中， 一旦用let或const声明一个变量，那么这个区块就变成块级作用域，用let或const声明的变量就“绑定”这个区域，不再受外部的影响。 在该变量声明之前不可以用，在语法上我们叫这种情况为：暂时性死区 (temporal dead zone，简称 TDZ)。
9. 箭头函数this指向
   当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。箭头函数没有自己的this，它的this是继承外面的，因此内部的this就是外层代码块的this。
10. 什么是闭包？闭包应用，闭包弊端。
    当一个函数能够记住并访问到其所在的词法作用域及作用域链，特别强调是在其定义的作用域外进行的访问，此时该函数和其上层执行上下文共同构成闭包。
    应用：
      在函数外读取函数内部的变量；
      让局部变量的值能够被保存下来；
      将模块的公有属性和方法暴露出来。
    弊端：
      闭包会使得函数中的变量被保存在内存中，增加内存消耗，不能滥用闭包，否则会造成网页的性能问题，在低版本IE中还可能导致内存泄露。
11. 什么是同源策略？跨域策略有哪几种？JSONP原理。
      所谓的同源是指，域名、协议、端口均为相同。
      由于浏览器的同源策略，禁止ajax从一个域名请求另外一个域名上的数据。是对JavaScript实施的安全限制。
      三种跨域策略：
      第一种：通过服务端代理请求。
      第二种：jsonp跨域
      第三种：CORS 跨域资源共享(xhr2)
      jsonp原理：
      利用js创建一个script标签，把json的url赋给script的scr属性，把这个script插入到页面里，让浏览器去跨域获取资源

12. prototype, \__proto__, constructor

    prototype：每个函数对象(Function.prototype除外)都有一个prototype属性（这个属性指向一个对象即 原型对象），是函数的一个默认属性，在函数的创建过程中由JS编译器自动添加
    _\_proto__：每个对象都有一个隐藏属性\_\_proto\_\_，用于指向创建它的构造函数的原型
    constructor：每个对象都有一个隐藏属性constructor，该属性指向对象的构造函数

13. 三次握手

    第一次握手：
    		建立连接时，客户端发送syn包（seq=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。
    第二次握手：
    		服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（seq=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；
    第三次握手：
    		客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手

14. 什么是原型链
      每个继承父函数的子函数的对象都包含一个内部属性\__proto__，该属性包含一个指针，指向父函数的prototype，若父函数的原型对象的\_\_proto\_\_属性为再上一层函数的原型，在此过程中就形成了原型链

15. 什么是作用域，什么是作用域链？
      作用域：通常来说，一段程序代码中所用到的名字并不总是有效／可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。
      作用域链：本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。

16. 什么是原型机制

    原型机制是一个内部链接，其本质是行为委托、对象间创建链接

17. GET和POST的区别
    语义化不一样

    ​     GET 倾向于从服务器获取数据
    ​     POST 倾向于向服务器提交数据

    传递参数的方式

    ​     GET 请求直接在地址栏后面拼接
    ​     POST 请求在请求体里面传递

    参数的大小限制

    ​     GET 请求一般不大于 2KB
    ​     POST 请求理论上没有上限

    缓存能力

    ​     GET 会被浏览器主动缓存
    ​     POST 不会被浏览器主动缓存

    安全性能

    ​     GET 请求相对安全性比较低
    ​     POST 请求相对安全性比较高

18. 垃圾回收机制
    各大浏览器通常采用的垃圾回收有两种方法：标记清除、引用计数
    标记清除：当变量进入执行环境时，将这个变量标记为“进入环境”。当变量离开执行环境时，则将其标记为“离开环境”，就销毁回收内存。
    引用计数：跟踪记录每个值被引用的次数，当引用次数变成0时，就销毁回收内存

19. call，bind，apply
    bind 函数不会自动执行，可以传入多个参数，第一个参数为this新的指向，之后的其他参数为传入函数的实参。
    call 函数会自动执行，可以传入多个参数，用法同bind。
    apply 函数会自动执行，可以传入两个参数，第一个参数为this新的指向，第二个参数为一个数组，将数组中的元素作为实参传入函数。

20. Cookie，localStorage
    cookie数据始终在同源的http请求中携带，localStorage不会自动把数据发送给服务器，仅在本地保存。
    存储大小限制也不同，cookie数据不能超过4K，localStorage存储大小的限制可以达到5M或更大。
    数据有效期不同，localStorage：始终有效，可以用作持久数据；cookie：只在设置的cookie过期时间之前有效。

21. 宏任务，微任务X  事件循环
    macro-task： 整体代码script、setTimeout、setInterval......
    micro-task：Promises、Object.observe......
    当一个脚本执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入调用栈中，然后从头开始执行。js引擎遇到一个异步事件后并不会一直等待其返回的结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会讲这个事件加入到事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中所有任务都执行完毕，主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码……，如此反复，这样就形成了一个无限的循环，这个过程被称为“事件循环”。

22. CommonJS，AMD，ES6 module
    根据CommonJs规范，每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见，CommonJS规范加载模块是同步的，加载完成才可以执行后面的操作。
    AMD是"Asynchronous ModuleDefinition"的简写，也就是异步模块定义。它采用异步方式加载模块。通过define方法去定义模块，require方法去加载模块。
    ES6 module模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。

23. 浏览器加载规则
    defer与async的区别是：
    defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；
    async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。
    一句话，defer是“渲染完再执行”，async是“下载完就执行”。